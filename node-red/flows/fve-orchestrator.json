[
    {
        "id": "d86bb11fab512182",
        "type": "tab",
        "label": "FVE Orchestrator",
        "disabled": false,
        "info": "Hlavní orchestrace FVE - plánování a rozhodování o módech",
        "env": []
    },
    {
        "id": "4580a451a0858d03",
        "type": "group",
        "z": "d86bb11fab512182",
        "name": "Plánování",
        "style": {
            "fill": "#e3f3d3",
            "label": true
        },
        "nodes": [
            "22e7b3b8965c20db",
            "f037d87ec94c7da2",
            "9333668b1d326a83",
            "9e0b46a9dfedea33",
            "df085ac4da095340",
            "39019d1a78677231",
            "517215d5f730e80c",
            "701e94d82c3aead0",
            "aabb001122334455",
            "aabb001122334466"
        ],
        "x": 14,
        "y": 19,
        "w": 1292,
        "h": 162
    },
    {
        "id": "c0d4d6462d4ebded",
        "type": "group",
        "z": "d86bb11fab512182",
        "name": "Exekuce plánu",
        "style": {
            "fill": "#d3e8f3",
            "label": true
        },
        "nodes": [
            "44d31ff3c04741b7",
            "c36915a8599c5282",
            "8eef6d1d51c9c644",
            "19a783a61de3519b",
            "f10a91fcb4de6bd3",
            "7f051a6595e57c3e",
            "185f95d7c56fe799",
            "a706b353f30c25d1",
            "a86bc5233cfa0458"
        ],
        "x": 134,
        "y": 219,
        "w": 752,
        "h": 242
    },
    {
        "id": "66210c073baa5af0",
        "type": "group",
        "z": "d86bb11fab512182",
        "name": "Kontrola priorit",
        "style": {
            "fill": "#f3e8d3",
            "label": true
        },
        "nodes": [
            "fc848e97e2c781c1",
            "376106d716756636",
            "dc8da09248ec1e29"
        ],
        "x": 174,
        "y": 519,
        "w": 672,
        "h": 82
    },
    {
        "id": "22e7b3b8965c20db",
        "type": "inject",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "Každou minutu",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "60",
        "crontab": "",
        "once": true,
        "onceDelay": "15",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 60,
        "wires": [
            [
                "9333668b1d326a83"
            ]
        ]
    },
    {
        "id": "f037d87ec94c7da2",
        "type": "link in",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "← Manuální trigger",
        "links": [],
        "x": 145,
        "y": 100,
        "wires": [
            [
                "9333668b1d326a83"
            ]
        ]
    },
    {
        "id": "9333668b1d326a83",
        "type": "function",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "Sbírka dat pro plánování",
        "func": "var config = global.get(\"fve_config\") || {};\nvar status = global.get(\"fve_status\") || {};\nvar prices = global.get(\"fve_prices_forecast\") || [];\nvar forecastZitra = global.get(\"forecast_vyroba_zitra\") || 0;\nvar zbyvajiciSolar = global.get(\"zbyvajici_solar_dnes\") || 0;\nvar consumptionAnalysis = global.get(\"fve_consumption_analysis\") || {};\n\nmsg.planData = {\n    config: config,\n    status: status,\n    prices: prices,\n    forecast: {\n        zitra: forecastZitra\n    },\n    zbyvajiciSolar: zbyvajiciSolar,\n    consumptionAnalysis: consumptionAnalysis,\n    timestamp: new Date().toISOString()\n};\n\nnode.status({fill:\"blue\", shape:\"dot\", text:\"Solar: \" + Math.round(zbyvajiciSolar) + \" kWh\"});\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            [
                "aabb001122334455"
            ]
        ]
    },
    {
        "id": "9e0b46a9dfedea33",
        "type": "function",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "Výpočet plánu na 12h (v13.1)",
        "func": "// FVE Smart Plan v13.1 - fix expensiveHours solar overlap + double-count - DB levely + fix peakDischarge + fresh prices\n// Opravy v12.1:\n//   - Zpět na DB levely (levelCheapestHourBuy) - prahy PRAH_LEVNA/DRAHA kalibrované na 24h\n//   - Fix peakDischarge: neaplikovat při nízkém SOC (< minSoc + 15)\n//   - Čtení cen přímo z global pro čerstvější data\n//   - Prefer hoursToday, fallback hoursTomorrow\n// Klíčový princip: ŠETŘIT je výchozí mód, NORMAL pro:\n//   1. Solární hodiny (nabíjení ze solaru zdarma)\n//   2. Drahé hodiny (level >= prah_draha_energie) - vybíjení baterie\n//   3. Večerní špička před nabíjením (vybíjení na minSOC) - POUZE při dostatečném SOC\n// Pravidla:\n//   - Nabíjet POUZE při nejnižších cenách a POUZE pokud to dává finanční smysl\n//   - NORMAL = solární hodiny + drahé hodiny + večerní špička\n//   - ŠETŘIT = všechny ostatní hodiny (výchozí)\n//   - Ztráty: 10% nabíjení + 10% vybíjení (round-trip ~81%)\n\nvar data = msg.planData;\nvar config = data.config || {};\nvar status = data.status || {};\nvar forecast = data.forecast || {};\n\n// Čti ceny PŘÍMO z global pro čerstvější data\n// v12.1: Preferuj čerstvé ceny z DB (přes msg.planData.prices)\nvar prices = data.prices || global.get(\"fve_prices_forecast\") || [];\n\nvar MODY = {\n    NORMAL: \"normal\",\n    SETRIT: \"setrit\",\n    NABIJET_ZE_SITE: \"nabijet_ze_site\",\n    PRODAVAT: \"prodavat\",\n    ZAKAZ_PRETOKU: \"zakaz_pretoku\"\n};\n\n// === PARAMETRY Z CONFIGU ===\nvar kapacitaBaterie = config.kapacita_baterie_kwh || 28;\nvar minSoc = config.min_soc || 20;\nvar maxDailySoc = config.max_daily_soc || 80;\nvar amortizace = config.amortizace_baterie_czk_kwh || 1.5;\nvar chargeEfficiency = config.charge_efficiency || 0.90;\nvar dischargeEfficiency = config.discharge_efficiency || 0.90;\nvar roundTripEfficiency = chargeEfficiency * dischargeEfficiency;\nvar chargeRateKwh = config.charge_rate_kwh || 5;\nvar socDropNormal = config.soc_drop_normal_pct || 5;\nvar dailyConsumptionKwh = config.daily_consumption_kwh || 20;\nvar PRAH_LEVNA = config.prah_levna_energie || 4;\nvar PRAH_DRAHA = config.prah_draha_energie || 12;\nvar horizont = config.plan_horizon_hours || 12;\nvar maxGridW = config.max_spotreba_sit_w || 22000;\nvar maxFeedInW = config.max_feed_in_w || 7600;\nvar prodejZBaterieEnabled = config.prodej_z_baterie_enabled === true;\nvar blokaceVybijeni = config.blokace_vybijeni === true;\nvar manualMod = config.manual_mod || \"auto\";\nvar letniRezim = config.letni_rezim === true;\nvar solarStartHour = config.solar_start_hour || 9;\nvar solarEndHour = config.solar_end_hour || 17;\nvar socDropSetrit = config.soc_drop_setrit_pct || 1;\n\n// === AKTUÁLNÍ STAV ===\nvar currentSoc = status.battery_soc || 50;\nvar forecastZitra = forecast.zitra || 0;\nvar remainingSolarKwh = data.zbyvajiciSolar || 0;\n\n// Sledování plného nabití\nvar lastFullCharge = global.get(\"fve_last_full_charge\") || null;\nif (!lastFullCharge) {\n    global.set(\"fve_last_full_charge\", new Date().toISOString());\n    lastFullCharge = global.get(\"fve_last_full_charge\");\n}\nvar daysSinceFullCharge = lastFullCharge\n    ? Math.floor((Date.now() - new Date(lastFullCharge).getTime()) / (1000 * 60 * 60 * 24))\n    : 999;\nif (currentSoc >= 99) {\n    global.set(\"fve_last_full_charge\", new Date().toISOString());\n}\n\nvar now = new Date();\nvar currentHour = now.getHours();\n\n// === POMOCNÁ FUNKCE: NAJDI CENOVÝ ZÁZNAM (v12.1) ===\n// Preferuje hoursToday + minute=0, pak hoursToday+jakákoliv minuta,\n// pak hoursTomorrow, pak cokoliv\nfunction findPriceEntry(hour, offset) {\n    var isNextDay = (currentHour + (offset || 0)) >= 24;\n    var preferDay = isNextDay ? \"hoursTomorrow\" : \"hoursToday\";\n    var otherDay = isNextDay ? \"hoursToday\" : \"hoursTomorrow\";\n    \n    // 1. Preferovaný den + hodina + minuta 0\n    for (var i = 0; i < prices.length; i++) {\n        if (prices[i].day === preferDay && prices[i].hour === hour && prices[i].minute === 0) {\n            return { entry: prices[i], method: \"exact_\" + preferDay };\n        }\n    }\n    \n    // 2. Preferovaný den + hodina (jakákoliv minuta)\n    for (var j = 0; j < prices.length; j++) {\n        if (prices[j].day === preferDay && prices[j].hour === hour) {\n            return { entry: prices[j], method: \"dayHour_\" + preferDay };\n        }\n    }\n    \n    // 3. Druhý den + hodina + minuta 0\n    for (var k = 0; k < prices.length; k++) {\n        if (prices[k].day === otherDay && prices[k].hour === hour && prices[k].minute === 0) {\n            return { entry: prices[k], method: \"exact_\" + otherDay };\n        }\n    }\n    \n    // 4. Druhý den + hodina (jakákoliv minuta)\n    for (var m = 0; m < prices.length; m++) {\n        if (prices[m].day === otherDay && prices[m].hour === hour) {\n            return { entry: prices[m], method: \"dayHour_\" + otherDay };\n        }\n    }\n    \n    // 5. Jakýkoliv den + hodina\n    for (var n = 0; n < prices.length; n++) {\n        if (prices[n].hour === hour) {\n            return { entry: prices[n], method: \"any_\" + (prices[n].day || \"noday\") };\n        }\n    }\n    \n    return { entry: null, method: \"none\" };\n}\n\n// === KROK 1: CENOVÁ MAPA HORIZONTU (DB levely) ===\nvar hourPrices = [];\nvar debugMatches = [];\nfor (var hi = 0; hi < horizont; hi++) {\n    var hh = (currentHour + hi) % 24;\n    var found = findPriceEntry(hh, hi);\n    var entry = found.entry;\n    hourPrices.push({\n        offset: hi,\n        hour: hh,\n        buy: entry ? (parseFloat(entry.priceCZKhourBuy) || 0) : 0,\n        sell: entry ? (parseFloat(entry.priceCZKhourProd) || 0) : 0,\n        levelBuy: entry ? (entry.levelCheapestHourBuy || 5) : 5,\n        levelSell: entry ? (entry.levelMostExpensiveHourProd || 5) : 5\n    });\n    debugMatches.push({\n        offset: hi,\n        hour: hh,\n        method: found.method,\n        day: entry ? entry.day : null,\n        min: entry ? entry.minute : null,\n        buy: entry ? entry.priceCZKhourBuy : null,\n        lvl: entry ? entry.levelCheapestHourBuy : null\n    });\n}\n\n// Debug log\nvar todayCount = 0;\nvar tomorrowCount = 0;\nfor (var dc = 0; dc < prices.length; dc++) {\n    if (prices[dc].day === \"hoursToday\") todayCount++;\n    else if (prices[dc].day === \"hoursTomorrow\") tomorrowCount++;\n}\nfor (var dbi = 0; dbi < Math.min(4, debugMatches.length); dbi++) {\n    var dm = debugMatches[dbi];\n}\n\n// === KROK 2: NAJDI DRAHÉ HODINY ===\n// v13.1 FIX: Exclude solar hours from expensive drain calculation\n// Solar hours CHARGE battery, they don't drain it\nvar expensiveHours = hourPrices.filter(function(hp) {\n    var h = (currentHour + hp.offset) % 24;\n    var isSolarHour = h >= solarStartHour && h < solarEndHour;\n    return hp.levelBuy >= PRAH_DRAHA && !isSolarHour;\n});\nvar avgExpensivePrice = 0;\nif (expensiveHours.length > 0) {\n    var sum = 0;\n    for (var ei = 0; ei < expensiveHours.length; ei++) {\n        sum += expensiveHours[ei].buy;\n    }\n    avgExpensivePrice = sum / expensiveHours.length;\n}\n\n// === KROK 3: FINANČNÍ SMYSLUPLNOST NABÍJENÍ ===\nvar viableChargingHours = [];\nfor (var vi = 0; vi < hourPrices.length; vi++) {\n    var chp = hourPrices[vi];\n    if (chp.levelBuy > PRAH_LEVNA) continue;\n    var effectiveCost = chp.buy / roundTripEfficiency + amortizace;\n    if (effectiveCost < avgExpensivePrice || avgExpensivePrice === 0) {\n        viableChargingHours.push(chp);\n    }\n}\nviableChargingHours.sort(function(a, b) { return a.buy - b.buy; });\n\n// === KROK 4: KOLIK ENERGIE POTŘEBUJI? ===\nvar hoursLeftToday = Math.max(0, 24 - currentHour);\nvar consumptionRemaining = dailyConsumptionKwh * hoursLeftToday / 24;\nvar solarForBattery = Math.max(0, remainingSolarKwh - consumptionRemaining);\n\n// Celková dostupná solární energie (dnes + zítra)\nvar totalSolarAvailable = solarForBattery + forecastZitra;\nvar isSolarPoorForecast = totalSolarAvailable < dailyConsumptionKwh * 0.3;\n\n// Energie potřebná pro drahé hodiny (NORMAL discharge)\nvar expensiveDrainKwh = expensiveHours.length * socDropNormal / 100 * kapacitaBaterie;\n\n// Celkový odpad za CELÝ horizont\nvar totalDrainPct = horizont * socDropSetrit;\nvar totalDrainKwh = totalDrainPct / 100 * kapacitaBaterie;\n\n// Predikovaný SOC na konci horizontu bez nabíjení\nvar projectedEndSoc = currentSoc - totalDrainPct;\nvar projectedEndSocWithSolar = projectedEndSoc + (solarForBattery / kapacitaBaterie * 100);\n\n// Kolik energie potřebuji ze sítě?\nvar availableKwh = ((currentSoc - minSoc) / 100) * kapacitaBaterie * dischargeEfficiency;\nvar gridChargeNeeded = 0;\nvar targetSocFromGrid = currentSoc;\n\n// NABÍJENÍ: pokud predikovaný SOC klesne pod minSOC + bezpečnostní marže\nvar safetyMargin = 10;\n// Při slabém solárním forecastu zvýšit ještě víc\nif (forecastZitra < dailyConsumptionKwh * 0.5) {\n    safetyMargin = 15;\n}\nif (projectedEndSocWithSolar < minSoc + safetyMargin) {\n    var neededPct = (minSoc + safetyMargin) - projectedEndSocWithSolar;\n    targetSocFromGrid = Math.min(maxDailySoc, currentSoc + Math.ceil(neededPct));\n    gridChargeNeeded = Math.max(0, ((targetSocFromGrid - currentSoc) / 100) * kapacitaBaterie / chargeEfficiency);\n}\n\n// Kontrola: pokud máme drahé hodiny a chceme vybíjet, potřebujeme dost energie\nif (expensiveHours.length > 0) {\n    // v13.1 FIX: Don't double-count. totalDrainKwh already has base (setrit) drain for all hours.\n    // Add only the EXTRA drain from expensive hours (normal rate - setrit rate).\n    var extraExpensiveDrain = expensiveHours.length * (socDropNormal - socDropSetrit) / 100 * kapacitaBaterie;\n    var neededForExpensive = totalDrainKwh + extraExpensiveDrain;\n    var currentAvailable = availableKwh + solarForBattery;\n    if (currentAvailable < neededForExpensive) {\n        var extraNeeded = (neededForExpensive - currentAvailable) / chargeEfficiency;\n        var newTarget = Math.min(maxDailySoc, currentSoc + Math.ceil(extraNeeded / kapacitaBaterie * 100));\n        if (newTarget > targetSocFromGrid) {\n            targetSocFromGrid = newTarget;\n            gridChargeNeeded = Math.max(0, ((targetSocFromGrid - currentSoc) / 100) * kapacitaBaterie / chargeEfficiency);\n        }\n    }\n}\n\nif (targetSocFromGrid <= currentSoc + 3) {\n    gridChargeNeeded = 0;\n    targetSocFromGrid = currentSoc;\n}\n\nvar maintenanceCharge = false;\nif (daysSinceFullCharge >= 10 && targetSocFromGrid < 100) {\n    targetSocFromGrid = 100;\n    gridChargeNeeded = ((100 - currentSoc) / 100) * kapacitaBaterie / chargeEfficiency;\n    maintenanceCharge = true;\n}\n\nvar hoursNeeded = Math.ceil(gridChargeNeeded / chargeRateKwh);\n\n// === KROK 5: PŘIŘAĎ NABÍJECÍ HODINY ===\nvar chargingOffsets = {};\nvar assignedHours = 0;\n\nif (viableChargingHours.length > 0) {\n    for (var ci = 0; ci < viableChargingHours.length && assignedHours < hoursNeeded; ci++) {\n        chargingOffsets[viableChargingHours[ci].offset] = true;\n        assignedHours++;\n    }\n}\n\n// Pokud potřebujeme nabít ale nejsou viable hodiny, použij nejlevnější\nif (assignedHours < hoursNeeded) {\n    var cheapestAvail = hourPrices.slice().filter(function(hp) { return !chargingOffsets[hp.offset]; });\n    cheapestAvail.sort(function(a, b) { return a.buy - b.buy; });\n    for (var ca = 0; ca < cheapestAvail.length && assignedHours < hoursNeeded; ca++) {\n        chargingOffsets[cheapestAvail[ca].offset] = true;\n        assignedHours++;\n    }\n    if (assignedHours > 0) {\n    }\n}\n\nif (maintenanceCharge && assignedHours < hoursNeeded) {\n    var remaining = hourPrices.filter(function(hp) { return !chargingOffsets[hp.offset]; });\n    remaining.sort(function(a, b) { return a.buy - b.buy; });\n    for (var ri = 0; ri < remaining.length && assignedHours < hoursNeeded; ri++) {\n        chargingOffsets[remaining[ri].offset] = true;\n        assignedHours++;\n    }\n}\n\nif (assignedHours < hoursNeeded && !maintenanceCharge) {\n    var actualChargeKwh = assignedHours * chargeRateKwh * chargeEfficiency;\n    targetSocFromGrid = Math.min(targetSocFromGrid,\n        currentSoc + Math.round(actualChargeKwh / kapacitaBaterie * 100));\n    gridChargeNeeded = actualChargeKwh;\n}\n\n// === KROK 6: IDENTIFIKUJ SOLÁRNÍ HODINY ===\n// FIX: Always create solar offsets for hours in solar window\n// Even if remaining solar forecast is 0, there's still production during daylight\n// Without this, late afternoon defaults to ŠETŘIT (battery stops discharging)\nvar solarOffsets = {};\nvar solarSocGainTotal = 0;\nvar solarHoursCount = 0;\nfor (var sh = 0; sh < horizont; sh++) {\n    var shh = (currentHour + sh) % 24;\n    if (shh >= solarStartHour && shh < solarEndHour && !chargingOffsets[sh]) {\n        solarOffsets[sh] = true;\n        solarHoursCount++;\n    }\n}\nif (solarHoursCount > 0 && remainingSolarKwh > 0) {\n    solarSocGainTotal = (remainingSolarKwh * chargeEfficiency / kapacitaBaterie) * 100;\n}\n\n// === KROK 7: IDENTIFIKUJ DRAHÉ HODINY (DB LEVEL) ===\nvar expensiveOffsets = {};\nfor (var eo = 0; eo < hourPrices.length; eo++) {\n    if (hourPrices[eo].levelBuy >= PRAH_DRAHA && !chargingOffsets[eo] && !solarOffsets[eo]) {\n        expensiveOffsets[eo] = true;\n    }\n}\n\n// === KROK 8: NAJDI PRVNÍ NABÍJECÍ OFFSET ===\nvar firstChargingOffset = horizont;\nfor (var fco = 0; fco < horizont; fco++) {\n    if (chargingOffsets[fco]) {\n        firstChargingOffset = fco;\n        break;\n    }\n}\n\n// === KROK 9: VEČERNÍ ŠPIČKA PŘED NABÍJENÍM ===\n// v12.1 FIX: Neaplikovat pokud SOC je nízký (< minSoc + 15)\n// Vybíjení před nabíjením dává smysl jen když máme dostatek energie\nvar peakDischargeOffsets = {};\n\nif (firstChargingOffset < horizont && currentSoc > minSoc + 15) {\n    var peakSoc = Math.min(100, currentSoc + solarSocGainTotal);\n    var totalDischargeNeeded = Math.max(0, peakSoc - minSoc);\n    var normalHoursNeeded = Math.ceil(totalDischargeNeeded / socDropNormal);\n    var dischargeStartOffset = Math.max(0, firstChargingOffset - normalHoursNeeded);\n    \n    for (var dso = dischargeStartOffset; dso < firstChargingOffset; dso++) {\n        if (!solarOffsets[dso] && !chargingOffsets[dso] && !expensiveOffsets[dso]) {\n            peakDischargeOffsets[dso] = true;\n        }\n    }\n} else if (firstChargingOffset < horizont) {\n}\n\n// === KROK 10: VÝPOČET MÓDU PRO KAŽDOU HODINU ===\nfunction calculateModeForHour(offset, priceData, simulatedSoc) {\n    if (manualMod !== \"auto\") {\n        return { mode: manualMod, reason: \"Manuální mód\" };\n    }\n\n    var priceSell = priceData.sell;\n    var levelSell = priceData.levelSell;\n    var levelBuy = priceData.levelBuy;\n\n    // PRIORITA 0: Záporná prodejní cena\n    if (priceSell <= 0) {\n        return { mode: MODY.ZAKAZ_PRETOKU, reason: \"Záporná prodejní cena\" };\n    }\n\n    // PRIORITA 1: Nabíjení ze sítě\n    if (chargingOffsets[offset] && simulatedSoc < targetSocFromGrid) {\n        return {\n            mode: MODY.NABIJET_ZE_SITE,\n            reason: \"Nabíjení na cíl \" + targetSocFromGrid + \"% (nyní \" + Math.round(simulatedSoc) + \"%)\"\n        };\n    }\n\n    // PRIORITA 2: Prodej z baterie při výhodné ceně\n    if (prodejZBaterieEnabled && levelSell <= 2 && simulatedSoc > minSoc + 20) {\n        var avgChargeCost = 0;\n        if (viableChargingHours.length > 0) {\n            var s = 0;\n            for (var ac = 0; ac < viableChargingHours.length; ac++) {\n                s += viableChargingHours[ac].buy;\n            }\n            avgChargeCost = s / viableChargingHours.length;\n        }\n        var revenuePerKwh = priceSell * dischargeEfficiency;\n        var costPerKwh = avgChargeCost / roundTripEfficiency + amortizace;\n        if (revenuePerKwh > costPerKwh) {\n            var dischRateKwh = maxFeedInW / 1000;\n            var socAfter = Math.max(minSoc,\n                simulatedSoc - (dischRateKwh / dischargeEfficiency / kapacitaBaterie * 100));\n            return {\n                mode: MODY.PRODAVAT,\n                reason: \"Prodej, SOC \" + Math.round(simulatedSoc) + \"% → ~\" + Math.round(socAfter) + \"%\"\n            };\n        }\n    }\n\n    // PRIORITA 3: Ochrana baterie - příliš nízký SOC\n    // FIX: During solar hours, only protect at absolute minSoc (not minSoc + 3)\n    // Solar production charges battery in NORMAL mode (PSP=0 = self-consumption)\n    // This prevents SOC oscillation causing battery to stop discharging every ~5 min\n    var isSolarHourNow = solarOffsets[offset] || false;\n    var socProtectionThreshold = isSolarHourNow ? minSoc : (minSoc + 3);\n    if (simulatedSoc <= socProtectionThreshold) {\n        return {\n            mode: MODY.SETRIT,\n            reason: \"Ochrana baterie (SOC \" + Math.round(simulatedSoc) + \"% ≤ \" + socProtectionThreshold + \"%)\"\n        };\n    }\n\n    // PRIORITA 4: NORMAL pro solární hodiny (nabíjení ze solaru zdarma)\n    if (solarOffsets[offset]) {\n        var solarGainEst = (remainingSolarKwh > 0) ? 3 : 0;\n        var expectedSocSolar = Math.min(100, simulatedSoc + solarGainEst);\n        return {\n            mode: MODY.NORMAL,\n            reason: \"Solární nabíjení, SOC \" + Math.round(simulatedSoc) + \"% → ~\" + Math.round(expectedSocSolar) + \"%\"\n        };\n    }\n\n    // PRIORITA 5: NORMAL pro drahé hodiny\n    if (expensiveOffsets[offset] && simulatedSoc > minSoc + 5) {\n        var expectedSocExpensive = Math.max(minSoc, simulatedSoc - socDropNormal);\n        return {\n            mode: MODY.NORMAL,\n            reason: \"Drahá energie, vybíjení SOC \" + Math.round(simulatedSoc) + \"% → ~\" + Math.round(expectedSocExpensive) + \"%\"\n        };\n    }\n\n    // PRIORITA 6: NORMAL pro večerní špičku před nabíjením (vybíjení na minSOC)\n    if (peakDischargeOffsets[offset] && simulatedSoc > minSoc + 5) {\n        var expectedSocDischarge = Math.max(minSoc, simulatedSoc - socDropNormal);\n        return {\n            mode: MODY.NORMAL,\n            reason: \"Vybíjení na minSOC, SOC \" + Math.round(simulatedSoc) + \"% → ~\" + Math.round(expectedSocDischarge) + \"%\"\n        };\n    }\n\n    // PRIORITA 7: ŠETŘIT (výchozí mód pro všechny ostatní hodiny)\n    return {\n        mode: MODY.SETRIT,\n        reason: \"Šetřím baterii (SOC \" + Math.round(simulatedSoc) + \"%)\"\n    };\n}\n\n// === SIMULACE SOC ===\nfunction simulateSocChange(mode, hour, soc) {\n    var isSolar = hour >= solarStartHour && hour < solarEndHour;\n    switch (mode) {\n        case MODY.NABIJET_ZE_SITE:\n            return Math.min(100, soc + (chargeRateKwh * chargeEfficiency / kapacitaBaterie * 100));\n        case MODY.PRODAVAT:\n            var dischRateKwh = maxFeedInW / 1000;\n            return Math.max(minSoc, soc - (dischRateKwh / dischargeEfficiency / kapacitaBaterie * 100));\n        case MODY.SETRIT:\n        case MODY.ZAKAZ_PRETOKU:\n            return Math.max(minSoc, soc - socDropSetrit);\n        case MODY.NORMAL:\n            if (isSolar && remainingSolarKwh > 0) {\n                return Math.min(100, soc + 3);\n            }\n            return Math.max(minSoc, soc - socDropNormal);\n        default:\n            return soc;\n    }\n}\n\n// === GENEROVÁNÍ PLÁNU ===\nvar modeNamesCZ = {\n    normal: \"Normální provoz\",\n    setrit: \"Šetřit baterii\",\n    nabijet_ze_site: \"Nabíjet ze sítě\",\n    prodavat: \"Prodávat do sítě\",\n    zakaz_pretoku: \"Zákaz přetoků\"\n};\n\nvar plan = [];\nvar simulatedSoc = currentSoc;\n\nfor (var pi = 0; pi < horizont; pi++) {\n    var planHour = (currentHour + pi) % 24;\n    var isNextDay = (currentHour + pi) >= 24;\n    var priceData = hourPrices[pi];\n    var result = calculateModeForHour(pi, priceData, simulatedSoc);\n    simulatedSoc = simulateSocChange(result.mode, planHour, simulatedSoc);\n    plan.push({\n        hour: planHour,\n        offset: pi,\n        mode: result.mode,\n        modeCZ: modeNamesCZ[result.mode] || result.mode,\n        reason: result.reason,\n        priceLevel: priceData.levelBuy,\n        priceBuy: priceData.buy,\n        priceSell: priceData.sell,\n        simulatedSoc: Math.round(simulatedSoc),\n        isNextDay: isNextDay,\n        isChargingHour: chargingOffsets[pi] || false,\n        isSolarHour: solarOffsets[pi] || false,\n        isExpensiveHour: expensiveOffsets[pi] || false,\n        isPeakDischargeHour: peakDischargeOffsets[pi] || false\n    });\n}\n\n// === LOGOVÁNÍ ===\nvar countSetrit = 0, countNormal = 0, countNabijet = 0;\nfor (var cs = 0; cs < plan.length; cs++) {\n    if (plan[cs].mode === MODY.SETRIT) countSetrit++;\n    else if (plan[cs].mode === MODY.NORMAL) countNormal++;\n    else if (plan[cs].mode === MODY.NABIJET_ZE_SITE) countNabijet++;\n}\n\n// Log first few plan entries\nfor (var lp = 0; lp < Math.min(4, plan.length); lp++) {\n    var pe = plan[lp];\n}\n\n// === VÝSTUP ===\nvar currentMode = plan.length > 0 ? plan[0].mode : MODY.NORMAL;\nvar currentReason = plan.length > 0 ? plan[0].reason : \"\";\n\nmsg.payload = {\n    currentMode: currentMode,\n    currentReason: currentReason,\n    currentHour: currentHour,\n    plan: plan,\n    config: { \n        prah_levna: PRAH_LEVNA,\n        prah_draha: PRAH_DRAHA\n    },\n    proteus: {\n        firstChargingOffset: firstChargingOffset,\n        peakDischargeHoursCount: Object.keys(peakDischargeOffsets).length,\n        solarHoursCount: Object.keys(solarOffsets).length,\n        expensiveHoursCount: Object.keys(expensiveOffsets).length,\n        peakSoc: Math.round(currentSoc + solarSocGainTotal),\n        totalSolarAvailable: Math.round(totalSolarAvailable * 10) / 10,\n        isSolarPoorForecast: isSolarPoorForecast,\n        projectedEndSoc: Math.round(projectedEndSocWithSolar)\n    },\n    smartCharging: {\n        targetSocFromGrid: targetSocFromGrid,\n        gridChargeNeeded: Math.round(gridChargeNeeded * 10) / 10,\n        hoursNeeded: hoursNeeded,\n        assignedHours: assignedHours,\n        viableHoursAvailable: viableChargingHours.length,\n        remainingSolar: Math.round(remainingSolarKwh * 10) / 10,\n        solarForBattery: Math.round(solarForBattery * 10) / 10,\n        roundTripEfficiency: Math.round(roundTripEfficiency * 100),\n        amortizace: amortizace,\n        daysToFullCharge: daysSinceFullCharge,\n        maintenanceCharge: maintenanceCharge\n    },\n    planSummary: {\n        setritHours: countSetrit,\n        normalHours: countNormal,\n        nabijetHours: countNabijet\n    },\n    status: {\n        soc: currentSoc,\n        remainingSolar: remainingSolarKwh,\n        forecastZitra: forecastZitra,\n        forecastDnes: forecast.dnes || 0,\n        prodejEnabled: prodejZBaterieEnabled,\n        blokaceVybijeni: blokaceVybijeni\n    },\n    generatedAt: now.toISOString()\n};\n\nvar modeColors = {\n    normal: \"green\",\n    setrit: \"yellow\",\n    nabijet_ze_site: \"blue\",\n    prodavat: \"red\",\n    zakaz_pretoku: \"purple\"\n};\nnode.status({\n    fill: modeColors[currentMode] || \"grey\",\n    shape: \"dot\",\n    text: \"v13 \" + currentMode\n        + \" | Š:\" + countSetrit + \" N:\" + countNormal + \" Nab:\" + countNabijet\n        + \" | SOC:\" + currentSoc + \"%→\" + targetSocFromGrid + \"%\"\n        + \" | Solar:\" + Math.round(totalSolarAvailable) + \"kWh\"\n        + \" | EndSOC:\" + Math.round(projectedEndSocWithSolar) + \"%\"\n});\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1160,
        "y": 60,
        "wires": [
            [
                "df085ac4da095340",
                "39019d1a78677231"
            ]
        ]
    },
    {
        "id": "df085ac4da095340",
        "type": "function",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "Ulož plán",
        "func": "global.set(\"fve_plan\", msg.payload);\nglobal.set(\"fve_current_mode\", msg.payload.currentMode);\n\nmsg.ha_update = {\n    state: msg.payload.currentMode,\n    attributes: {\n        current_mode: msg.payload.currentMode,\n        current_reason: msg.payload.currentReason,\n        current_hour: msg.payload.currentHour,\n        plan: msg.payload.plan,\n        soc: msg.payload.status.soc,\n        forecast_dnes: msg.payload.status.forecastDnes,\n        forecast_zitra: msg.payload.status.forecastZitra,\n        last_update: msg.payload.generatedAt,\n        debug: msg.payload.debug || {}\n    }\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 140,
        "wires": [
            [
                "517215d5f730e80c"
            ]
        ]
    },
    {
        "id": "39019d1a78677231",
        "type": "debug",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "Plan Debug",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1170,
        "y": 140,
        "wires": []
    },
    {
        "id": "517215d5f730e80c",
        "type": "function",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "Aktualizuj HA sensor",
        "func": "var planData = msg.payload || {};\nvar currentMode = planData.currentMode || \"normal\";\nvar currentHour = planData.currentHour || new Date().getHours();\nvar planArray = planData.plan || [];\n\nnode.status({fill:\"green\", shape:\"dot\", text: \"Mód: \" + currentMode + \", hodina: \" + currentHour});\n\nmsg.payload = JSON.stringify({\n    current_mode: currentMode,\n    current_reason: planData.currentReason || \"\",\n    current_hour: currentHour,\n    plan: planArray,\n    soc: planData.status ? planData.status.soc : null,\n    forecast_dnes: planData.status ? planData.status.forecastDnes : null,\n    forecast_zitra: planData.status ? planData.status.forecastZitra : null,\n    debug: planData.debug || \"\",\n    last_update: new Date().toISOString()\n}, null, 2);\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 620,
        "y": 140,
        "wires": [
            [
                "701e94d82c3aead0"
            ]
        ]
    },
    {
        "id": "701e94d82c3aead0",
        "type": "file",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "Zapiš plán do souboru",
        "filename": "/homeassistant/fve_plan.json",
        "filenameType": "str",
        "appendNewline": false,
        "createDir": false,
        "overwriteFile": "true",
        "encoding": "utf8",
        "x": 880,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "44d31ff3c04741b7",
        "type": "inject",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "Každých 15 sekund",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "15",
        "crontab": "",
        "once": true,
        "onceDelay": "20",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 280,
        "y": 260,
        "wires": [
            [
                "c36915a8599c5282"
            ]
        ]
    },
    {
        "id": "c36915a8599c5282",
        "type": "function",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "Kontrola podmínek",
        "func": "var config = global.get(\"fve_config\") || {};\nvar plan = global.get(\"fve_plan\") || {};\n// FIX: Read planned mode from plan object (immutable, set by planner only)\n// Previously read from fve_current_mode which was overwritten by override logic\nvar planMode = (plan && plan.currentMode) ? plan.currentMode : \"normal\";\nvar manualMod = config.manual_mod || \"auto\";\n\nvar currentMode = planMode;\nif (manualMod !== \"auto\") {\n    currentMode = manualMod;\n}\n\nvar wasEnabled = flow.get(\"automatizace_was_enabled\") || false;\nif (config.automatizace_enabled === false) {\n    if (wasEnabled) {\n        flow.set(\"automatizace_was_enabled\", false);\n        global.set(\"fve_current_mode\", \"normal\");\n        msg.currentMode = \"normal\";\n        msg.doReset = true;\n        node.status({fill:\"yellow\", shape:\"dot\", text:\"Reset do normalniho modu\"});\n        return msg;\n    }\n    node.status({fill:\"grey\", shape:\"ring\", text:\"Automatizace vypnuta\"});\n    return null;\n}\nflow.set(\"automatizace_was_enabled\", true);\n\nvar autoNabijeni = global.get(\"auto_nabijeni_aktivni\") || false;\nvar cerpadloTopi = global.get(\"cerpadlo_topi\") || false;\n\n// FIX: Removed override normal->setrit when heat pump/car active.\n// Root cause of battery charging in Normal mode:\n//   Override switched to Setrit which set max_discharge_power=0 and\n//   scheduled_soc=currentSoc, causing solar->battery and grid->consumption.\n// The planner already assigns correct modes. Individual modes (e.g. Nabijet)\n// already adjust power_set_point for high-priority consumers.\n\n// Update display mode\nglobal.set(\"fve_current_mode\", currentMode);\n\nmsg.autoNabijeniAktivni = autoNabijeni;\nmsg.cerpadloTopi = cerpadloTopi;\nmsg.currentMode = currentMode;\nmsg.config = config;\nmsg.plan = plan;\n\nvar modeSource = manualMod !== \"auto\" ? \"(manualni)\" : \"(auto)\";\nvar infoText = \"\";\nif (cerpadloTopi) infoText += \" | Cerpadlo topi\";\nif (autoNabijeni) infoText += \" | Auto nabiji\";\nnode.status({fill: manualMod !== \"auto\" ? \"blue\" : \"green\", shape:\"dot\", text: \"Mod: \" + currentMode + \" \" + modeSource + infoText});\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 260,
        "wires": [
            [
                "8eef6d1d51c9c644"
            ]
        ]
    },
    {
        "id": "8eef6d1d51c9c644",
        "type": "function",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "Rozhodnutí o akci",
        "func": "var mode = msg.currentMode;\nvar skipBattery = msg.skipBatteryControl || false;\n\nswitch (mode) {\n    case \"normal\": msg.modeIndex = 0; break;\n    case \"setrit\": msg.modeIndex = 1; break;\n    case \"nabijet_ze_site\": msg.modeIndex = 2; break;\n    case \"prodavat\": msg.modeIndex = 3; break;\n    case \"zakaz_pretoku\": msg.modeIndex = 4; break;\n    default: msg.modeIndex = 0;\n}\n\nmsg.skipBatteryControl = skipBattery;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 340,
        "wires": [
            [
                "19a783a61de3519b"
            ]
        ]
    },
    {
        "id": "19a783a61de3519b",
        "type": "switch",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "Směrování podle módu",
        "property": "modeIndex",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "0",
                "vt": "num"
            },
            {
                "t": "eq",
                "v": "1",
                "vt": "num"
            },
            {
                "t": "eq",
                "v": "2",
                "vt": "num"
            },
            {
                "t": "eq",
                "v": "3",
                "vt": "num"
            },
            {
                "t": "eq",
                "v": "4",
                "vt": "num"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 5,
        "x": 670,
        "y": 340,
        "wires": [
            [
                "f10a91fcb4de6bd3"
            ],
            [
                "7f051a6595e57c3e"
            ],
            [
                "185f95d7c56fe799"
            ],
            [
                "a706b353f30c25d1"
            ],
            [
                "a86bc5233cfa0458"
            ]
        ]
    },
    {
        "id": "f10a91fcb4de6bd3",
        "type": "link out",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "→ Normal",
        "mode": "link",
        "links": [
            "8b55cfc5181b9eb7"
        ],
        "x": 845,
        "y": 260,
        "wires": []
    },
    {
        "id": "7f051a6595e57c3e",
        "type": "link out",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "→ Šetřit",
        "mode": "link",
        "links": [
            "ec611f6aba7d5c59"
        ],
        "x": 845,
        "y": 300,
        "wires": []
    },
    {
        "id": "185f95d7c56fe799",
        "type": "link out",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "→ Nabíjet",
        "mode": "link",
        "links": [
            "1d98a0541716ce58"
        ],
        "x": 845,
        "y": 340,
        "wires": []
    },
    {
        "id": "a706b353f30c25d1",
        "type": "link out",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "→ Prodávat",
        "mode": "link",
        "links": [
            "179ed150020d459c"
        ],
        "x": 845,
        "y": 380,
        "wires": []
    },
    {
        "id": "a86bc5233cfa0458",
        "type": "link out",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "→ Zákaz přetoků",
        "mode": "link",
        "links": [
            "c682224043634fcd"
        ],
        "x": 845,
        "y": 420,
        "wires": []
    },
    {
        "id": "fc848e97e2c781c1",
        "type": "server-state-changed",
        "z": "d86bb11fab512182",
        "g": "66210c073baa5af0",
        "name": "Změna stavu wallboxu",
        "server": "c7421fe2.cb11c",
        "version": 6,
        "outputs": 1,
        "exposeAsEntityConfig": "",
        "entities": {
            "entity": [
                "sensor.charger_state_garage",
                "sensor.stav_wallboxu_venek"
            ],
            "substring": [],
            "regex": []
        },
        "outputInitially": true,
        "stateType": "str",
        "ifState": "",
        "ifStateType": "str",
        "ifStateOperator": "is",
        "outputOnlyOnStateChange": true,
        "for": "0",
        "forType": "num",
        "forUnits": "minutes",
        "ignorePrevStateNull": false,
        "ignorePrevStateUnknown": false,
        "ignorePrevStateUnavailable": false,
        "ignoreCurrentStateUnknown": false,
        "ignoreCurrentStateUnavailable": false,
        "outputProperties": [
            {
                "property": "payload",
                "propertyType": "msg",
                "value": "string",
                "valueType": "entityState"
            },
            {
                "property": "entity_id",
                "propertyType": "msg",
                "value": "",
                "valueType": "str"
            }
        ],
        "x": 300,
        "y": 560,
        "wires": [
            [
                "376106d716756636"
            ]
        ]
    },
    {
        "id": "376106d716756636",
        "type": "function",
        "z": "d86bb11fab512182",
        "g": "66210c073baa5af0",
        "name": "Kontrola nabíjení auta",
        "func": "var state = msg.payload;\nvar chargingStates = [\"Charging\", \"Nabíjení\", \"2\"];\nvar isCharging = chargingStates.some(function(s) {\n    return state.toLowerCase().indexOf(s.toLowerCase()) !== -1 || state === s;\n});\nmsg.autoNabijeni = isCharging;\nnode.status({fill: isCharging ? \"yellow\" : \"green\", shape:\"dot\", text: isCharging ? \"Auto se nabíjí\" : \"Auto se nenabíjí\"});\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 532,
        "y": 560,
        "wires": [
            [
                "dc8da09248ec1e29"
            ]
        ]
    },
    {
        "id": "dc8da09248ec1e29",
        "type": "change",
        "z": "d86bb11fab512182",
        "g": "66210c073baa5af0",
        "name": "Nastav global",
        "rules": [
            {
                "t": "set",
                "p": "auto_nabijeni_aktivni",
                "pt": "global",
                "to": "autoNabijeni",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 740,
        "y": 560,
        "wires": [
            []
        ]
    },
    {
        "id": "aabb001122334455",
        "type": "sqlite",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "mydb": "6d97960f9560e05b",
        "sqlquery": "fixed",
        "sql": "SELECT * FROM \"own_energy_prices_total\"",
        "name": "Čti čerstvé ceny z DB",
        "x": 620,
        "y": 60,
        "wires": [
            [
                "aabb001122334466"
            ]
        ]
    },
    {
        "id": "aabb001122334466",
        "type": "function",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "Aktualizuj ceny v planData",
        "func": "// Nahraď stará data čerstvými z DB\nvar freshPrices = msg.payload || [];\nif (freshPrices.length > 0) {\n    msg.planData.prices = freshPrices;\n    // Aktualizuj i global pro ostatní\n    global.set(\"fve_prices_forecast\", freshPrices);\n    node.status({fill:\"green\", shape:\"dot\", text: freshPrices.length + \" cen z DB\"});\n} else {\n    node.status({fill:\"yellow\", shape:\"dot\", text: \"DB prázdná, použit global\"});\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 60,
        "wires": [
            [
                "9e0b46a9dfedea33"
            ]
        ]
    },
    {
        "id": "c7421fe2.cb11c",
        "type": "server",
        "name": "Home Assistant",
        "addon": true,
        "rejectUnauthorizedCerts": true,
        "ha_boolean": "",
        "connectionDelay": false,
        "cacheJson": false,
        "heartbeat": false,
        "heartbeatInterval": "",
        "statusSeparator": "",
        "enableGlobalContextStore": false
    },
    {
        "id": "6d97960f9560e05b",
        "type": "sqlitedb",
        "db": "/homeassistant/home-assistant_v2.db",
        "mode": "RWC"
    },
    {
        "id": "2f65d436b2bf6251",
        "type": "global-config",
        "env": [],
        "modules": {
            "node-red-contrib-home-assistant-websocket": "0.80.3",
            "node-red-node-sqlite": "1.1.1"
        }
    }
]
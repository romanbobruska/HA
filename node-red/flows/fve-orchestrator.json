[
    {
        "id": "d86bb11fab512182",
        "type": "tab",
        "label": "FVE Orchestrator",
        "disabled": false,
        "info": "Hlavní orchestrace FVE - plánování a rozhodování o módech",
        "env": []
    },
    {
        "id": "4580a451a0858d03",
        "type": "group",
        "z": "d86bb11fab512182",
        "name": "Plánování",
        "style": {
            "fill": "#e3f3d3",
            "label": true
        },
        "nodes": [
            "22e7b3b8965c20db",
            "f037d87ec94c7da2",
            "9333668b1d326a83",
            "9e0b46a9dfedea33",
            "df085ac4da095340",
            "39019d1a78677231",
            "517215d5f730e80c",
            "701e94d82c3aead0",
            "aabb001122334455",
            "aabb001122334466"
        ],
        "x": 14,
        "y": 19,
        "w": 1292,
        "h": 162
    },
    {
        "id": "c0d4d6462d4ebded",
        "type": "group",
        "z": "d86bb11fab512182",
        "name": "Exekuce plánu",
        "style": {
            "fill": "#d3e8f3",
            "label": true
        },
        "nodes": [
            "44d31ff3c04741b7",
            "c36915a8599c5282",
            "8eef6d1d51c9c644",
            "19a783a61de3519b",
            "f10a91fcb4de6bd3",
            "7f051a6595e57c3e",
            "185f95d7c56fe799",
            "a706b353f30c25d1",
            "a86bc5233cfa0458"
        ],
        "x": 134,
        "y": 219,
        "w": 752,
        "h": 242
    },
    {
        "id": "66210c073baa5af0",
        "type": "group",
        "z": "d86bb11fab512182",
        "name": "Kontrola priorit",
        "style": {
            "fill": "#f3e8d3",
            "label": true
        },
        "nodes": [
            "fc848e97e2c781c1",
            "376106d716756636",
            "dc8da09248ec1e29"
        ],
        "x": 174,
        "y": 519,
        "w": 672,
        "h": 82
    },
    {
        "id": "22e7b3b8965c20db",
        "type": "inject",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "Každou minutu",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "60",
        "crontab": "",
        "once": true,
        "onceDelay": "15",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 60,
        "wires": [
            [
                "9333668b1d326a83"
            ]
        ]
    },
    {
        "id": "f037d87ec94c7da2",
        "type": "link in",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "← Manuální trigger",
        "links": [],
        "x": 145,
        "y": 100,
        "wires": [
            [
                "9333668b1d326a83"
            ]
        ]
    },
    {
        "id": "9333668b1d326a83",
        "type": "function",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "Sbírka dat pro plánování",
        "func": "var config = global.get(\"fve_config\") || {};\nvar status = global.get(\"fve_status\") || {};\nvar prices = global.get(\"fve_prices_forecast\") || [];\nvar forecastZitra = global.get(\"forecast_vyroba_zitra\") || 0;\nvar zbyvajiciSolar = global.get(\"zbyvajici_solar_dnes\") || 0;\nvar consumptionAnalysis = global.get(\"fve_consumption_analysis\") || {};\n\nmsg.planData = {\n    config: config,\n    status: status,\n    prices: prices,\n    forecast: {\n        zitra: forecastZitra\n    },\n    zbyvajiciSolar: zbyvajiciSolar,\n    consumptionAnalysis: consumptionAnalysis,\n    timestamp: new Date().toISOString()\n};\n\nnode.status({fill:\"blue\", shape:\"dot\", text:\"Solar: \" + Math.round(zbyvajiciSolar) + \" kWh\"});\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            [
                "aabb001122334455"
            ]
        ]
    },
    {
        "id": "9e0b46a9dfedea33",
        "type": "function",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "Výpočet plánu na 12h (v16.0)",
        "func": "// FVE Smart Plan v16.0 - dynamický práh vybíjení\n// v16.0: Dynamický effectiveThreshold\n//   - Config prahy (PRAH_LEVNA, PRAH_DRAHA) zůstávají beze změny\n//   - Algoritmus snižuje effectiveThreshold od PRAH_DRAHA dolů\n//   - Snižuje dokud kapacita baterie + solár stačí pokrýt spotřebu\n//   - Hodiny se přidávají do Normal od nejdražších dolů\n//   - Šetřit POUZE v nejlevnějších hodinách kde baterie nestačí\n//   - Čím větší výroba/kapacita → méně Šetřit → méně odběr ze sítě\n// Pravidla:\n//   - Nabíjet POUZE při nejnižších cenách a POUZE pokud to dává finanční smysl\n//   - NORMAL = vybíjení baterie (drahé + střední hodiny dle kapacity)\n//   - ŠETŘIT = šetření baterie (pouze nejlevnější hodiny)\n//   - Ztráty: 10% nabíjení + 10% vybíjení (round-trip ~81%)\n\nvar data = msg.planData;\nvar config = data.config || {};\nvar status = data.status || {};\nvar forecast = data.forecast || {};\n\n// Čti ceny PŘÍMO z global pro čerstvější data\nvar prices = data.prices || global.get(\"fve_prices_forecast\") || [];\n\nvar MODY = {\n    NORMAL: \"normal\",\n    SETRIT: \"setrit\",\n    NABIJET_ZE_SITE: \"nabijet_ze_site\",\n    PRODAVAT: \"prodavat\",\n    ZAKAZ_PRETOKU: \"zakaz_pretoku\",\n    SOLAR_CHARGING: \"solar_charging\"\n};\n\n// === PARAMETRY Z CONFIGU ===\nvar kapacitaBaterie = config.kapacita_baterie_kwh || 28;\nvar minSoc = config.min_soc || 20;\nvar maxDailySoc = config.max_daily_soc || 80;\nvar amortizace = config.amortizace_baterie_czk_kwh || 1.5;\nvar chargeEfficiency = config.charge_efficiency || 0.90;\nvar dischargeEfficiency = config.discharge_efficiency || 0.90;\nvar roundTripEfficiency = chargeEfficiency * dischargeEfficiency;\nvar chargeRateKwh = config.charge_rate_kwh || 5;\nvar socDropNormal = config.soc_drop_normal_pct || 5;\nvar dailyConsumptionKwh = config.daily_consumption_kwh || 20;\nvar PRAH_LEVNA = config.prah_levna_energie || 4;\nvar PRAH_DRAHA = config.prah_draha_energie || 12;\nvar horizont = config.plan_horizon_hours || 12;\nvar maxGridW = config.max_spotreba_sit_w || 22000;\nvar maxFeedInW = config.max_feed_in_w || 7600;\nvar prodejZBaterieEnabled = config.prodej_z_baterie_enabled === true;\nvar blokaceVybijeni = config.blokace_vybijeni === true;\nvar manualMod = config.manual_mod || \"auto\";\nvar letniRezim = config.letni_rezim === true;\nvar solarStartHour = config.solar_start_hour || 9;\nvar solarEndHour = config.solar_end_hour || 17;\nvar socDropSetrit = config.soc_drop_setrit_pct || 1;\n\n// === AKTUÁLNÍ STAV ===\nvar currentSoc = status.battery_soc || 50;\nvar forecastZitra = forecast.zitra || 0;\nvar remainingSolarKwh = data.zbyvajiciSolar || 0;\n\n// Sledování plného nabití\nvar lastFullCharge = global.get(\"fve_last_full_charge\") || null;\nif (!lastFullCharge) {\n    global.set(\"fve_last_full_charge\", new Date().toISOString());\n    lastFullCharge = global.get(\"fve_last_full_charge\");\n}\nvar daysSinceFullCharge = lastFullCharge\n    ? Math.floor((Date.now() - new Date(lastFullCharge).getTime()) / (1000 * 60 * 60 * 24))\n    : 999;\nif (currentSoc >= 99) {\n    global.set(\"fve_last_full_charge\", new Date().toISOString());\n}\n\nvar now = new Date();\nvar currentHour = now.getHours();\n\n// === POMOCNÁ FUNKCE: NAJDI CENOVÝ ZÁZNAM ===\nfunction findPriceEntry(hour, offset) {\n    var isNextDay = (currentHour + (offset || 0)) >= 24;\n    var preferDay = isNextDay ? \"hoursTomorrow\" : \"hoursToday\";\n    var otherDay = isNextDay ? \"hoursToday\" : \"hoursTomorrow\";\n    \n    for (var i = 0; i < prices.length; i++) {\n        if (prices[i].day === preferDay && prices[i].hour === hour && prices[i].minute === 0) {\n            return { entry: prices[i], method: \"exact_\" + preferDay };\n        }\n    }\n    for (var j = 0; j < prices.length; j++) {\n        if (prices[j].day === preferDay && prices[j].hour === hour) {\n            return { entry: prices[j], method: \"dayHour_\" + preferDay };\n        }\n    }\n    for (var k = 0; k < prices.length; k++) {\n        if (prices[k].day === otherDay && prices[k].hour === hour && prices[k].minute === 0) {\n            return { entry: prices[k], method: \"exact_\" + otherDay };\n        }\n    }\n    for (var m = 0; m < prices.length; m++) {\n        if (prices[m].day === otherDay && prices[m].hour === hour) {\n            return { entry: prices[m], method: \"dayHour_\" + otherDay };\n        }\n    }\n    for (var n = 0; n < prices.length; n++) {\n        if (prices[n].hour === hour) {\n            return { entry: prices[n], method: \"any_\" + (prices[n].day || \"noday\") };\n        }\n    }\n    return { entry: null, method: \"none\" };\n}\n\n// === KROK 1: CENOVÁ MAPA HORIZONTU ===\nvar hourPrices = [];\nvar debugMatches = [];\nfor (var hi = 0; hi < horizont; hi++) {\n    var hh = (currentHour + hi) % 24;\n    var found = findPriceEntry(hh, hi);\n    var entry = found.entry;\n    hourPrices.push({\n        offset: hi,\n        hour: hh,\n        buy: entry ? (parseFloat(entry.priceCZKhourBuy) || 0) : 0,\n        sell: entry ? (parseFloat(entry.priceCZKhourProd) || 0) : 0,\n        levelBuy: entry ? (entry.levelCheapestHourBuy || 5) : 5,\n        levelSell: entry ? (entry.levelMostExpensiveHourProd || 5) : 5\n    });\n    debugMatches.push({\n        offset: hi, hour: hh, method: found.method,\n        day: entry ? entry.day : null, min: entry ? entry.minute : null,\n        buy: entry ? entry.priceCZKhourBuy : null, lvl: entry ? entry.levelCheapestHourBuy : null\n    });\n}\n\n// === KROK 2: NAJDI DRAHÉ HODINY (pro finanční kalkulaci nabíjení) ===\nvar expensiveHours = hourPrices.filter(function(hp) {\n    var h = (currentHour + hp.offset) % 24;\n    var isSolarHour = h >= solarStartHour && h < solarEndHour;\n    return hp.levelBuy >= PRAH_DRAHA && !isSolarHour;\n});\nvar avgExpensivePrice = 0;\nif (expensiveHours.length > 0) {\n    var sum = 0;\n    for (var ei = 0; ei < expensiveHours.length; ei++) {\n        sum += expensiveHours[ei].buy;\n    }\n    avgExpensivePrice = sum / expensiveHours.length;\n}\n\n// === KROK 3: FINANČNÍ SMYSLUPLNOST NABÍJENÍ ===\nvar viableChargingHours = [];\nfor (var vi = 0; vi < hourPrices.length; vi++) {\n    var chp = hourPrices[vi];\n    if (chp.levelBuy > PRAH_LEVNA) continue;\n    var effectiveCost = chp.buy / roundTripEfficiency + amortizace;\n    if (effectiveCost < avgExpensivePrice || avgExpensivePrice === 0) {\n        viableChargingHours.push(chp);\n    }\n}\nviableChargingHours.sort(function(a, b) { return a.buy - b.buy; });\n\n// === KROK 4: KOLIK ENERGIE POTŘEBUJI? ===\nvar hoursLeftToday = Math.max(0, 24 - currentHour);\nvar consumptionRemaining = dailyConsumptionKwh * hoursLeftToday / 24;\nvar solarForBattery = Math.max(0, remainingSolarKwh - consumptionRemaining);\nvar totalSolarAvailable = solarForBattery + forecastZitra;\nvar isSolarPoorForecast = totalSolarAvailable < dailyConsumptionKwh * 0.3;\n\nvar expensiveDrainKwh = expensiveHours.length * socDropNormal / 100 * kapacitaBaterie;\nvar totalDrainPct = horizont * socDropSetrit;\nvar totalDrainKwh = totalDrainPct / 100 * kapacitaBaterie;\nvar projectedEndSoc = currentSoc - totalDrainPct;\nvar projectedEndSocWithSolar = projectedEndSoc + (solarForBattery / kapacitaBaterie * 100);\n\nvar availableKwh = ((currentSoc - minSoc) / 100) * kapacitaBaterie * dischargeEfficiency;\nvar gridChargeNeeded = 0;\nvar targetSocFromGrid = currentSoc;\n\nvar safetyMargin = 10;\nif (forecastZitra < dailyConsumptionKwh * 0.5) {\n    safetyMargin = 15;\n}\n\n// Dynamický optimalSoc\nvar baseDrainPct = horizont * socDropSetrit;\nvar extraExpensivePct = expensiveHours.length * (socDropNormal - socDropSetrit);\nvar totalNeededPct = baseDrainPct + extraExpensivePct;\nvar solarContribPct = (solarForBattery / kapacitaBaterie) * 100;\nvar netNeededPct = Math.max(0, totalNeededPct - solarContribPct);\nvar optimalSoc = Math.min(maxDailySoc, minSoc + Math.ceil(netNeededPct) + safetyMargin);\n\n// Strategie 1: Ochranné nabíjení\nif (projectedEndSocWithSolar < minSoc + safetyMargin) {\n    var neededPct = (minSoc + safetyMargin) - projectedEndSocWithSolar;\n    targetSocFromGrid = Math.min(maxDailySoc, currentSoc + Math.ceil(neededPct));\n    gridChargeNeeded = Math.max(0, ((targetSocFromGrid - currentSoc) / 100) * kapacitaBaterie / chargeEfficiency);\n}\n// Strategie 2: Opportunistické nabíjení\nif (currentSoc < optimalSoc && viableChargingHours.length > 0) {\n    var opportunisticTarget = Math.min(maxDailySoc, optimalSoc);\n    var opportunisticNeeded = ((opportunisticTarget - currentSoc) / 100) * kapacitaBaterie / chargeEfficiency;\n    if (opportunisticNeeded > 0) {\n        targetSocFromGrid = Math.max(targetSocFromGrid, opportunisticTarget);\n        gridChargeNeeded = ((targetSocFromGrid - currentSoc) / 100) * kapacitaBaterie / chargeEfficiency;\n    }\n}\n\nif (expensiveHours.length > 0) {\n    var extraExpensiveDrain = expensiveHours.length * (socDropNormal - socDropSetrit) / 100 * kapacitaBaterie;\n    var neededForExpensive = totalDrainKwh + extraExpensiveDrain;\n    var currentAvailable = availableKwh + solarForBattery;\n    if (currentAvailable < neededForExpensive) {\n        var extraNeeded = (neededForExpensive - currentAvailable) / chargeEfficiency;\n        var newTarget = Math.min(maxDailySoc, currentSoc + Math.ceil(extraNeeded / kapacitaBaterie * 100));\n        if (newTarget > targetSocFromGrid) {\n            targetSocFromGrid = newTarget;\n            gridChargeNeeded = Math.max(0, ((targetSocFromGrid - currentSoc) / 100) * kapacitaBaterie / chargeEfficiency);\n        }\n    }\n}\n\nif (targetSocFromGrid <= currentSoc + 3) {\n    gridChargeNeeded = 0;\n    targetSocFromGrid = currentSoc;\n}\n\nvar maintenanceCharge = false;\nif (daysSinceFullCharge >= 10 && targetSocFromGrid < 100) {\n    targetSocFromGrid = 100;\n    gridChargeNeeded = ((100 - currentSoc) / 100) * kapacitaBaterie / chargeEfficiency;\n    maintenanceCharge = true;\n}\n\nvar hoursNeeded = Math.ceil(gridChargeNeeded / chargeRateKwh);\n\n// === KROK 5: PŘIŘAĎ NABÍJECÍ HODINY ===\nvar chargingOffsets = {};\nvar assignedHours = 0;\n\nvar opportunisticCharging = false;\nif (currentSoc < optimalSoc && targetSocFromGrid < optimalSoc) {\n    var opportunisticTarget2 = Math.min(maxDailySoc, optimalSoc);\n    var additionalKwh = ((opportunisticTarget2 - targetSocFromGrid) / 100) * kapacitaBaterie / chargeEfficiency;\n    var additionalHours = Math.ceil(additionalKwh / chargeRateKwh);\n    var cheapHours = hourPrices.filter(function(hp) { \n        return hp.levelBuy <= PRAH_LEVNA && (currentHour + hp.offset) < 24; \n    });\n    cheapHours.sort(function(a, b) { return a.buy - b.buy; });\n    if (cheapHours.length > 0 && additionalHours > 0) {\n        var totalHoursNeeded = Math.min(\n            Math.ceil(((opportunisticTarget2 - currentSoc) / 100) * kapacitaBaterie / chargeEfficiency / chargeRateKwh),\n            cheapHours.length\n        );\n        hoursNeeded = totalHoursNeeded;\n        targetSocFromGrid = Math.min(maxDailySoc, currentSoc + (hoursNeeded * chargeRateKwh * chargeEfficiency / kapacitaBaterie * 100));\n        gridChargeNeeded = ((targetSocFromGrid - currentSoc) / 100) * kapacitaBaterie / chargeEfficiency;\n        opportunisticCharging = true;\n    }\n}\n\nif (viableChargingHours.length > 0) {\n    for (var ci = 0; ci < viableChargingHours.length && assignedHours < hoursNeeded; ci++) {\n        chargingOffsets[viableChargingHours[ci].offset] = true;\n        assignedHours++;\n    }\n}\n\nif (assignedHours < hoursNeeded) {\n    var cheapestAvail = hourPrices.slice().filter(function(hp) {\n        return !chargingOffsets[hp.offset] && hp.levelBuy <= PRAH_LEVNA;\n    });\n    cheapestAvail.sort(function(a, b) { return a.buy - b.buy; });\n    for (var ca = 0; ca < cheapestAvail.length && assignedHours < hoursNeeded; ca++) {\n        chargingOffsets[cheapestAvail[ca].offset] = true;\n        assignedHours++;\n    }\n}\n\nif (maintenanceCharge && assignedHours < hoursNeeded) {\n    var remaining = hourPrices.filter(function(hp) {\n        return !chargingOffsets[hp.offset] && hp.levelBuy < PRAH_DRAHA;\n    });\n    remaining.sort(function(a, b) { return a.buy - b.buy; });\n    for (var ri = 0; ri < remaining.length && assignedHours < hoursNeeded; ri++) {\n        chargingOffsets[remaining[ri].offset] = true;\n        assignedHours++;\n    }\n}\n\nif (assignedHours < hoursNeeded && !maintenanceCharge) {\n    var actualChargeKwh = assignedHours * chargeRateKwh * chargeEfficiency;\n    targetSocFromGrid = Math.min(targetSocFromGrid,\n        currentSoc + Math.round(actualChargeKwh / kapacitaBaterie * 100));\n    gridChargeNeeded = actualChargeKwh;\n}\n\n// === KROK 6: IDENTIFIKUJ SOLÁRNÍ HODINY ===\nvar solarOffsets = {};\nvar solarSocGainTotal = 0;\nvar solarHoursCount = 0;\nfor (var sh = 0; sh < horizont; sh++) {\n    var shh = (currentHour + sh) % 24;\n    if (shh >= solarStartHour && shh < solarEndHour && !chargingOffsets[sh]) {\n        solarOffsets[sh] = true;\n        solarHoursCount++;\n    }\n}\nif (solarHoursCount > 0 && remainingSolarKwh > 0) {\n    solarSocGainTotal = (remainingSolarKwh * chargeEfficiency / kapacitaBaterie) * 100;\n}\n\n// === KROK 7: DYNAMICKÝ PRÁH VYBÍJENÍ ===\n// Logika:\n// 1. Spočítat dostupnou energii baterie (currentSoc - minSoc) + solár\n// 2. Najít hodiny kde se dá vybíjet (ne-solární, ne-nabíjecí)\n// 3. Seřadit od nejdražšího levelu dolů\n// 4. Postupně přidávat hodiny do Normal (vybíjení) dokud kapacita stačí\n// 5. effectiveThreshold se automaticky sníží\n// Výsledek: čím větší kapacita/výroba → více Normal hodin → méně Šetřit → méně odběr ze sítě\n\n// Najdi hodiny kde se dá vybíjet (ne-solární, ne-nabíjecí)\nvar dischargeCandidate = [];\nfor (var dc = 0; dc < hourPrices.length; dc++) {\n    if (!solarOffsets[dc] && !chargingOffsets[dc]) {\n        dischargeCandidate.push({\n            offset: dc,\n            hour: hourPrices[dc].hour,\n            levelBuy: hourPrices[dc].levelBuy,\n            buy: hourPrices[dc].buy\n        });\n    }\n}\n\n// Seřadit od NEJDRAŽŠÍHO levelu dolů (nejdřív vybíjet při nejdražších cenách)\ndischargeCandidate.sort(function(a, b) {\n    if (b.levelBuy !== a.levelBuy) return b.levelBuy - a.levelBuy;\n    return b.buy - a.buy; // při stejném levelu preferuj vyšší absolutní cenu\n});\n\n// Spočítat dostupnou energii pro vybíjení\nvar availableBatteryKwh = Math.max(0, (currentSoc - minSoc) / 100 * kapacitaBaterie * dischargeEfficiency);\nvar availableSolarKwh = remainingSolarKwh; // solár pokryje spotřebu přímo\nvar totalAvailableKwh = availableBatteryKwh + availableSolarKwh;\n\n// Spotřeba za hodinu (průměr)\nvar consumptionPerHour = dailyConsumptionKwh / 24;\n\n// Najdi offset dalšího nabíjení (solár NEBO grid charging)\nvar nextRechargeOffset = horizont; // default: konec horizontu\n// Grid charging\nfor (var nro = 0; nro < horizont; nro++) {\n    if (chargingOffsets[nro]) {\n        nextRechargeOffset = nro;\n        break;\n    }\n}\n// Solární hodiny (zítra ráno) - pokud je dříve než grid charging\nfor (var nso = 0; nso < horizont; nso++) {\n    if (solarOffsets[nso] && nso < nextRechargeOffset) {\n        nextRechargeOffset = nso;\n        break;\n    }\n}\n\n// Kolik hodin spotřeby musíme pokrýt do dalšího nabíjení?\nvar hoursToRecharge = nextRechargeOffset;\nvar consumptionToRecharge = hoursToRecharge * consumptionPerHour;\n\n// Kolik kWh baterie můžeme vydat na vybíjení (Normal mode)?\n// = dostupná baterie - spotřeba v Šetřit hodinách (kde baterie nekryje spotřebu)\n// V Normal mode baterie kryje spotřebu, v Šetřit mode spotřebu kryje síť\nvar energyBudgetKwh = availableBatteryKwh;\n\n// Přidávej hodiny do Normal od nejdražších dolů, dokud kapacita stačí\nvar dischargeOffsets = {};\nvar effectiveThreshold = PRAH_DRAHA; // začni od config prahu\nvar usedEnergyKwh = 0;\nvar dischargeDebug = [];\n\nfor (var di = 0; di < dischargeCandidate.length; di++) {\n    var cand = dischargeCandidate[di];\n    var energyForThisHour = socDropNormal / 100 * kapacitaBaterie; // kWh spotřebované z baterie za hodinu Normal\n    \n    if (usedEnergyKwh + energyForThisHour <= energyBudgetKwh) {\n        // Kapacita stačí - přidej hodinu do Normal (vybíjení)\n        dischargeOffsets[cand.offset] = true;\n        usedEnergyKwh += energyForThisHour;\n        effectiveThreshold = Math.min(effectiveThreshold, cand.levelBuy);\n        dischargeDebug.push({\n            offset: cand.offset,\n            hour: cand.hour,\n            level: cand.levelBuy,\n            price: cand.buy,\n            action: \"NORMAL\",\n            usedKwh: Math.round(usedEnergyKwh * 10) / 10,\n            budgetKwh: Math.round(energyBudgetKwh * 10) / 10\n        });\n    } else {\n        // Kapacita nestačí - tato a levnější hodiny budou Šetřit\n        dischargeDebug.push({\n            offset: cand.offset,\n            hour: cand.hour,\n            level: cand.levelBuy,\n            price: cand.buy,\n            action: \"SETRIT (budget exceeded)\",\n            usedKwh: Math.round(usedEnergyKwh * 10) / 10,\n            budgetKwh: Math.round(energyBudgetKwh * 10) / 10\n        });\n    }\n}\n\n// === KROK 8: VÝPOČET MÓDU PRO KAŽDOU HODINU ===\nfunction calculateModeForHour(offset, priceData, simulatedSoc) {\n    if (manualMod !== \"auto\") {\n        return { mode: manualMod, reason: \"Manuální mód\" };\n    }\n\n    var priceSell = priceData.sell;\n    var levelSell = priceData.levelSell;\n    var levelBuy = priceData.levelBuy;\n\n    // PRIORITA 0: Záporná prodejní cena\n    if (priceSell <= 0) {\n        return { mode: MODY.ZAKAZ_PRETOKU, reason: \"Záporná prodejní cena\" };\n    }\n\n    // PRIORITA 1: Nabíjení ze sítě\n    if (chargingOffsets[offset] && simulatedSoc < targetSocFromGrid) {\n        return {\n            mode: MODY.NABIJET_ZE_SITE,\n            reason: \"Nabíjení na cíl \" + Math.round(targetSocFromGrid) + \"% (nyní \" + Math.round(simulatedSoc) + \"%)\"\n        };\n    }\n\n    // PRIORITA 2: Prodej z baterie při výhodné ceně\n    if (prodejZBaterieEnabled && levelSell <= 2 && simulatedSoc > minSoc + 20) {\n        var avgChargeCost = 0;\n        if (viableChargingHours.length > 0) {\n            var s = 0;\n            for (var ac = 0; ac < viableChargingHours.length; ac++) {\n                s += viableChargingHours[ac].buy;\n            }\n            avgChargeCost = s / viableChargingHours.length;\n        }\n        var revenuePerKwh = priceSell * dischargeEfficiency;\n        var costPerKwh = avgChargeCost / roundTripEfficiency + amortizace;\n        if (revenuePerKwh > costPerKwh) {\n            var dischRateKwh = maxFeedInW / 1000;\n            var socAfter = Math.max(minSoc,\n                simulatedSoc - (dischRateKwh / dischargeEfficiency / kapacitaBaterie * 100));\n            return {\n                mode: MODY.PRODAVAT,\n                reason: \"Prodej, SOC \" + Math.round(simulatedSoc) + \"% → ~\" + Math.round(socAfter) + \"%\"\n            };\n        }\n    }\n\n    // PRIORITA 3: Ochrana baterie - příliš nízký SOC\n    if (simulatedSoc <= minSoc) {\n        return {\n            mode: MODY.SETRIT,\n            reason: \"Ochrana baterie (SOC \" + Math.round(simulatedSoc) + \"% ≤ \" + minSoc + \"%)\"\n        };\n    }\n\n    // PRIORITA 4: SOLAR_CHARGING nebo NORMAL pro solární hodiny\n    if (solarOffsets[offset]) {\n        var solarGainEst = (remainingSolarKwh > 0) ? 3 : 0;\n        var expectedSocSolar = Math.min(100, simulatedSoc + solarGainEst);\n        \n        if (levelBuy <= PRAH_LEVNA) {\n            return {\n                mode: MODY.SOLAR_CHARGING,\n                reason: \"Solární nabíjení (levná energie), SOC \" + Math.round(simulatedSoc) + \"% → ~\" + Math.round(expectedSocSolar) + \"%\"\n            };\n        }\n        \n        return {\n            mode: MODY.NORMAL,\n            reason: \"Solární hodina, SOC \" + Math.round(simulatedSoc) + \"% → ~\" + Math.round(expectedSocSolar) + \"%\"\n        };\n    }\n\n    // PRIORITA 5: NORMAL pro hodiny vybrané dynamickým prahem (vybíjení)\n    if (dischargeOffsets[offset] && simulatedSoc > minSoc) {\n        var expectedSocDischarge = Math.max(minSoc, simulatedSoc - socDropNormal);\n        var priceInfo = levelBuy >= PRAH_DRAHA ? \"drahá\" : \"střední\";\n        return {\n            mode: MODY.NORMAL,\n            reason: priceInfo + \" (Lv\" + levelBuy + \"≥eff\" + effectiveThreshold + \"), vybíjení SOC \" + Math.round(simulatedSoc) + \"% → ~\" + Math.round(expectedSocDischarge) + \"%\"\n        };\n    }\n\n    // PRIORITA 6: ŠETŘIT (výchozí mód - levné hodiny kde baterie nestačí)\n    return {\n        mode: MODY.SETRIT,\n        reason: \"Šetřím (Lv\" + levelBuy + \"<eff\" + effectiveThreshold + \"), SOC \" + Math.round(simulatedSoc) + \"%\"\n    };\n}\n\n// === SIMULACE SOC ===\nfunction simulateSocChange(mode, hour, soc) {\n    var isSolar = hour >= solarStartHour && hour < solarEndHour;\n    switch (mode) {\n        case MODY.NABIJET_ZE_SITE:\n            return Math.min(100, soc + (chargeRateKwh * chargeEfficiency / kapacitaBaterie * 100));\n        case MODY.PRODAVAT:\n            var dischRateKwh = maxFeedInW / 1000;\n            return Math.max(minSoc, soc - (dischRateKwh / dischargeEfficiency / kapacitaBaterie * 100));\n        case MODY.SETRIT:\n            return soc;\n        case MODY.ZAKAZ_PRETOKU:\n            return Math.max(minSoc, soc - socDropSetrit);\n        case MODY.NORMAL:\n            if (isSolar && remainingSolarKwh > 0) {\n                return Math.min(100, soc + 3);\n            }\n            return Math.max(minSoc, soc - socDropNormal);\n        default:\n            return soc;\n    }\n}\n\n// === GENEROVÁNÍ PLÁNU ===\nvar modeNamesCZ = {\n    normal: \"Normální provoz\",\n    setrit: \"Šetřit baterii\",\n    nabijet_ze_site: \"Nabíjet ze sítě\",\n    prodavat: \"Prodávat do sítě\",\n    zakaz_pretoku: \"Zákaz přetoků\"\n};\n\nvar plan = [];\nvar simulatedSoc = currentSoc;\n\nfor (var pi = 0; pi < horizont; pi++) {\n    var planHour = (currentHour + pi) % 24;\n    var isNextDay = (currentHour + pi) >= 24;\n    var priceData = hourPrices[pi];\n    var result = calculateModeForHour(pi, priceData, simulatedSoc);\n    simulatedSoc = simulateSocChange(result.mode, planHour, simulatedSoc);\n    plan.push({\n        hour: planHour,\n        offset: pi,\n        mode: result.mode,\n        modeCZ: modeNamesCZ[result.mode] || result.mode,\n        reason: result.reason,\n        priceLevel: priceData.levelBuy,\n        priceBuy: priceData.buy,\n        priceSell: priceData.sell,\n        simulatedSoc: Math.round(simulatedSoc),\n        isNextDay: isNextDay,\n        isChargingHour: chargingOffsets[pi] || false,\n        isSolarHour: solarOffsets[pi] || false,\n        isDischargeHour: dischargeOffsets[pi] || false\n    });\n}\n\n// === LOGOVÁNÍ ===\nvar countSetrit = 0, countNormal = 0, countNabijet = 0;\nfor (var cs = 0; cs < plan.length; cs++) {\n    if (plan[cs].mode === MODY.SETRIT) countSetrit++;\n    else if (plan[cs].mode === MODY.NORMAL) countNormal++;\n    else if (plan[cs].mode === MODY.NABIJET_ZE_SITE) countNabijet++;\n}\n\n// === VÝSTUP ===\nvar currentMode = plan.length > 0 ? plan[0].mode : MODY.NORMAL;\nvar currentReason = plan.length > 0 ? plan[0].reason : \"\";\n\nmsg.payload = {\n    currentMode: currentMode,\n    currentReason: currentReason,\n    currentHour: currentHour,\n    plan: plan,\n    dischargeDebug: dischargeDebug,\n    config: { \n        prah_levna: PRAH_LEVNA,\n        prah_draha: PRAH_DRAHA,\n        effective_threshold: effectiveThreshold\n    },\n    proteus: {\n        firstChargingOffset: nextRechargeOffset,\n        dischargeHoursCount: Object.keys(dischargeOffsets).length,\n        solarHoursCount: Object.keys(solarOffsets).length,\n        energyBudgetKwh: Math.round(energyBudgetKwh * 10) / 10,\n        usedEnergyKwh: Math.round(usedEnergyKwh * 10) / 10,\n        effectiveThreshold: effectiveThreshold,\n        peakSoc: Math.round(currentSoc + solarSocGainTotal),\n        totalSolarAvailable: Math.round(totalSolarAvailable * 10) / 10,\n        isSolarPoorForecast: isSolarPoorForecast,\n        projectedEndSoc: Math.round(projectedEndSocWithSolar)\n    },\n    smartCharging: {\n        targetSocFromGrid: Math.round(targetSocFromGrid),\n        gridChargeNeeded: Math.round(gridChargeNeeded * 10) / 10,\n        hoursNeeded: hoursNeeded,\n        assignedHours: assignedHours,\n        viableHoursAvailable: viableChargingHours.length,\n        remainingSolar: Math.round(remainingSolarKwh * 10) / 10,\n        solarForBattery: Math.round(solarForBattery * 10) / 10,\n        roundTripEfficiency: Math.round(roundTripEfficiency * 100),\n        amortizace: amortizace,\n        daysToFullCharge: daysSinceFullCharge,\n        maintenanceCharge: maintenanceCharge\n    },\n    planSummary: {\n        setritHours: countSetrit,\n        normalHours: countNormal,\n        nabijetHours: countNabijet\n    },\n    status: {\n        soc: currentSoc,\n        remainingSolar: remainingSolarKwh,\n        forecastZitra: forecastZitra,\n        forecastDnes: forecast.dnes || 0,\n        prodejEnabled: prodejZBaterieEnabled,\n        blokaceVybijeni: blokaceVybijeni\n    },\n    generatedAt: now.toISOString()\n};\n\nvar modeColors = {\n    normal: \"green\",\n    setrit: \"yellow\",\n    nabijet_ze_site: \"blue\",\n    prodavat: \"red\",\n    zakaz_pretoku: \"purple\"\n};\nnode.status({\n    fill: modeColors[currentMode] || \"grey\",\n    shape: \"dot\",\n    text: \"v16 \" + currentMode\n        + \" | Š:\" + countSetrit + \" N:\" + countNormal + \" Nab:\" + countNabijet\n        + \" | effThr:\" + effectiveThreshold + \" (cfg:\" + PRAH_DRAHA + \")\"\n        + \" | SOC:\" + currentSoc + \"%→\" + targetSocFromGrid + \"%\"\n        + \" | Bat:\" + Math.round(energyBudgetKwh) + \"kWh\"\n});\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1160,
        "y": 60,
        "wires": [
            [
                "df085ac4da095340",
                "39019d1a78677231"
            ]
        ]
    },
    {
        "id": "df085ac4da095340",
        "type": "function",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "Ulož plán",
        "func": "global.set(\"fve_plan\", msg.payload);\nglobal.set(\"fve_current_mode\", msg.payload.currentMode);\n\nmsg.ha_update = {\n    state: msg.payload.currentMode,\n    attributes: {\n        current_mode: msg.payload.currentMode,\n        current_reason: msg.payload.currentReason,\n        current_hour: msg.payload.currentHour,\n        plan: msg.payload.plan,\n        soc: msg.payload.status.soc,\n        forecast_dnes: msg.payload.status.forecastDnes,\n        forecast_zitra: msg.payload.status.forecastZitra,\n        last_update: msg.payload.generatedAt,\n        debug: msg.payload.debug || {}\n    }\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 140,
        "wires": [
            [
                "517215d5f730e80c"
            ]
        ]
    },
    {
        "id": "39019d1a78677231",
        "type": "debug",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "Plan Debug",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1170,
        "y": 140,
        "wires": []
    },
    {
        "id": "517215d5f730e80c",
        "type": "function",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "Aktualizuj HA sensor",
        "func": "var planData = msg.payload || {};\nvar currentMode = planData.currentMode || \"normal\";\nvar currentHour = planData.currentHour || new Date().getHours();\nvar planArray = planData.plan || [];\n\nnode.status({fill:\"green\", shape:\"dot\", text: \"Mód: \" + currentMode + \", hodina: \" + currentHour});\n\nmsg.payload = JSON.stringify({\n    current_mode: currentMode,\n    current_reason: planData.currentReason || \"\",\n    current_hour: currentHour,\n    plan: planArray,\n    soc: planData.status ? planData.status.soc : null,\n    forecast_dnes: planData.status ? planData.status.forecastDnes : null,\n    forecast_zitra: planData.status ? planData.status.forecastZitra : null,\n    debug: planData.debug || \"\",\n    last_update: new Date().toISOString()\n}, null, 2);\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 620,
        "y": 140,
        "wires": [
            [
                "701e94d82c3aead0"
            ]
        ]
    },
    {
        "id": "701e94d82c3aead0",
        "type": "file",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "Zapiš plán do souboru",
        "filename": "/homeassistant/fve_plan.json",
        "filenameType": "str",
        "appendNewline": false,
        "createDir": false,
        "overwriteFile": "true",
        "encoding": "utf8",
        "x": 880,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "44d31ff3c04741b7",
        "type": "inject",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "Každých 15 sekund",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "15",
        "crontab": "",
        "once": true,
        "onceDelay": "20",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 280,
        "y": 260,
        "wires": [
            [
                "c36915a8599c5282"
            ]
        ]
    },
    {
        "id": "c36915a8599c5282",
        "type": "function",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "Kontrola podmínek",
        "func": "var config = global.get(\"fve_config\") || {};\nvar plan = global.get(\"fve_plan\") || {};\n// FIX: Read planned mode from plan object (immutable, set by planner only)\n// Previously read from fve_current_mode which was overwritten by override logic\nvar planMode = (plan && plan.currentMode) ? plan.currentMode : \"normal\";\nvar manualMod = config.manual_mod || \"auto\";\n\nvar currentMode = planMode;\nif (manualMod !== \"auto\") {\n    currentMode = manualMod;\n}\n\nvar wasEnabled = flow.get(\"automatizace_was_enabled\") || false;\nif (config.automatizace_enabled === false) {\n    if (wasEnabled) {\n        flow.set(\"automatizace_was_enabled\", false);\n        global.set(\"fve_current_mode\", \"normal\");\n        msg.currentMode = \"normal\";\n        msg.doReset = true;\n        node.status({fill:\"yellow\", shape:\"dot\", text:\"Reset do normalniho modu\"});\n        return msg;\n    }\n    node.status({fill:\"grey\", shape:\"ring\", text:\"Automatizace vypnuta\"});\n    return null;\n}\nflow.set(\"automatizace_was_enabled\", true);\n\nvar autoNabijeni = global.get(\"auto_nabijeni_aktivni\") || false;\nvar cerpadloTopi = global.get(\"cerpadlo_topi\") || false;\n\n// FIX: Removed override normal->setrit when heat pump/car active.\n// Root cause of battery charging in Normal mode:\n//   Override switched to Setrit which set max_discharge_power=0 and\n//   scheduled_soc=currentSoc, causing solar->battery and grid->consumption.\n// The planner already assigns correct modes. Individual modes (e.g. Nabijet)\n// already adjust power_set_point for high-priority consumers.\n\n// Update display mode\nglobal.set(\"fve_current_mode\", currentMode);\n\nmsg.autoNabijeniAktivni = autoNabijeni;\nmsg.cerpadloTopi = cerpadloTopi;\nmsg.currentMode = currentMode;\nmsg.config = config;\nmsg.plan = plan;\n\nvar modeSource = manualMod !== \"auto\" ? \"(manualni)\" : \"(auto)\";\nvar infoText = \"\";\nif (cerpadloTopi) infoText += \" | Cerpadlo topi\";\nif (autoNabijeni) infoText += \" | Auto nabiji\";\nnode.status({fill: manualMod !== \"auto\" ? \"blue\" : \"green\", shape:\"dot\", text: \"Mod: \" + currentMode + \" \" + modeSource + infoText});\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 260,
        "wires": [
            [
                "8eef6d1d51c9c644"
            ]
        ]
    },
    {
        "id": "8eef6d1d51c9c644",
        "type": "function",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "Rozhodnutí o akci",
        "func": "var mode = msg.currentMode;\nvar skipBattery = msg.skipBatteryControl || false;\n\nswitch (mode) {\n    case \"normal\": msg.modeIndex = 0; break;\n    case \"setrit\": msg.modeIndex = 1; break;\n    case \"nabijet_ze_site\": msg.modeIndex = 2; break;\n    case \"prodavat\": msg.modeIndex = 3; break;\n    case \"zakaz_pretoku\": msg.modeIndex = 4; break;\n    case \"solar_charging\": msg.modeIndex = 5; break;\n    default: msg.modeIndex = 0;\n}\n\nmsg.skipBatteryControl = skipBattery;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 340,
        "wires": [
            [
                "19a783a61de3519b"
            ]
        ]
    },
    {
        "id": "19a783a61de3519b",
        "type": "switch",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "Směrování podle módu",
        "property": "modeIndex",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "0",
                "vt": "num"
            },
            {
                "t": "eq",
                "v": "1",
                "vt": "num"
            },
            {
                "t": "eq",
                "v": "2",
                "vt": "num"
            },
            {
                "t": "eq",
                "v": "3",
                "vt": "num"
            },
            {
                "t": "eq",
                "v": "4",
                "vt": "num"
            },
            {
                "t": "eq",
                "v": "5",
                "vt": "num"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 6,
        "x": 670,
        "y": 340,
        "wires": [
            [
                "f10a91fcb4de6bd3"
            ],
            [
                "7f051a6595e57c3e"
            ],
            [
                "185f95d7c56fe799"
            ],
            [
                "a706b353f30c25d1"
            ],
            [
                "a86bc5233cfa0458"
            ],
            [
                "solar123456789abc"
            ]
        ]
    },
    {
        "id": "f10a91fcb4de6bd3",
        "type": "link out",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "→ Normal",
        "mode": "link",
        "links": [
            "8b55cfc5181b9eb7"
        ],
        "x": 845,
        "y": 260,
        "wires": []
    },
    {
        "id": "7f051a6595e57c3e",
        "type": "link out",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "→ Šetřit",
        "mode": "link",
        "links": [
            "ec611f6aba7d5c59"
        ],
        "x": 845,
        "y": 300,
        "wires": []
    },
    {
        "id": "185f95d7c56fe799",
        "type": "link out",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "→ Nabíjet",
        "mode": "link",
        "links": [
            "1d98a0541716ce58"
        ],
        "x": 845,
        "y": 340,
        "wires": []
    },
    {
        "id": "a706b353f30c25d1",
        "type": "link out",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "→ Prodávat",
        "mode": "link",
        "links": [
            "179ed150020d459c"
        ],
        "x": 845,
        "y": 380,
        "wires": []
    },
    {
        "id": "a86bc5233cfa0458",
        "type": "link out",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "→ Zákaz přetoků",
        "mode": "link",
        "links": [
            "c682224043634fcd"
        ],
        "x": 845,
        "y": 420,
        "wires": []
    },
    {
        "id": "fc848e97e2c781c1",
        "type": "server-state-changed",
        "z": "d86bb11fab512182",
        "g": "66210c073baa5af0",
        "name": "Změna stavu wallboxu",
        "server": "c7421fe2.cb11c",
        "version": 6,
        "outputs": 1,
        "exposeAsEntityConfig": "",
        "entities": {
            "entity": [
                "sensor.charger_state_garage",
                "sensor.stav_wallboxu_venek"
            ],
            "substring": [],
            "regex": []
        },
        "outputInitially": true,
        "stateType": "str",
        "ifState": "",
        "ifStateType": "str",
        "ifStateOperator": "is",
        "outputOnlyOnStateChange": true,
        "for": "0",
        "forType": "num",
        "forUnits": "minutes",
        "ignorePrevStateNull": false,
        "ignorePrevStateUnknown": false,
        "ignorePrevStateUnavailable": false,
        "ignoreCurrentStateUnknown": false,
        "ignoreCurrentStateUnavailable": false,
        "outputProperties": [
            {
                "property": "payload",
                "propertyType": "msg",
                "value": "string",
                "valueType": "entityState"
            },
            {
                "property": "entity_id",
                "propertyType": "msg",
                "value": "",
                "valueType": "str"
            }
        ],
        "x": 300,
        "y": 560,
        "wires": [
            [
                "376106d716756636"
            ]
        ]
    },
    {
        "id": "376106d716756636",
        "type": "function",
        "z": "d86bb11fab512182",
        "g": "66210c073baa5af0",
        "name": "Kontrola nabíjení auta",
        "func": "var state = msg.payload;\nvar chargingStates = [\"Charging\", \"Nabíjení\", \"2\"];\nvar isCharging = chargingStates.some(function(s) {\n    return state.toLowerCase().indexOf(s.toLowerCase()) !== -1 || state === s;\n});\nmsg.autoNabijeni = isCharging;\nnode.status({fill: isCharging ? \"yellow\" : \"green\", shape:\"dot\", text: isCharging ? \"Auto se nabíjí\" : \"Auto se nenabíjí\"});\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 532,
        "y": 560,
        "wires": [
            [
                "dc8da09248ec1e29"
            ]
        ]
    },
    {
        "id": "dc8da09248ec1e29",
        "type": "change",
        "z": "d86bb11fab512182",
        "g": "66210c073baa5af0",
        "name": "Nastav global",
        "rules": [
            {
                "t": "set",
                "p": "auto_nabijeni_aktivni",
                "pt": "global",
                "to": "autoNabijeni",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 740,
        "y": 560,
        "wires": [
            []
        ]
    },
    {
        "id": "aabb001122334455",
        "type": "sqlite",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "mydb": "6d97960f9560e05b",
        "sqlquery": "fixed",
        "sql": "SELECT * FROM \"own_energy_prices_total\"",
        "name": "Čti čerstvé ceny z DB",
        "x": 620,
        "y": 60,
        "wires": [
            [
                "aabb001122334466"
            ]
        ]
    },
    {
        "id": "aabb001122334466",
        "type": "function",
        "z": "d86bb11fab512182",
        "g": "4580a451a0858d03",
        "name": "Aktualizuj ceny v planData",
        "func": "// Nahraď stará data čerstvými z DB\nvar freshPrices = msg.payload || [];\nif (freshPrices.length > 0) {\n    msg.planData.prices = freshPrices;\n    // Aktualizuj i global pro ostatní\n    global.set(\"fve_prices_forecast\", freshPrices);\n    node.status({fill:\"green\", shape:\"dot\", text: freshPrices.length + \" cen z DB\"});\n} else {\n    node.status({fill:\"yellow\", shape:\"dot\", text: \"DB prázdná, použit global\"});\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 60,
        "wires": [
            [
                "9e0b46a9dfedea33"
            ]
        ]
    },
    {
        "id": "solar123456789abc",
        "type": "link out",
        "z": "d86bb11fab512182",
        "g": "c0d4d6462d4ebded",
        "name": "→ Solární nabíjení",
        "mode": "link",
        "links": [
            "e93b8f3e662c6190"
        ],
        "x": 845,
        "y": 460,
        "wires": []
    },
    {
        "id": "c7421fe2.cb11c",
        "type": "server",
        "name": "Home Assistant",
        "addon": true,
        "rejectUnauthorizedCerts": true,
        "ha_boolean": "",
        "connectionDelay": false,
        "cacheJson": false,
        "heartbeat": false,
        "heartbeatInterval": "",
        "statusSeparator": "",
        "enableGlobalContextStore": false
    },
    {
        "id": "6d97960f9560e05b",
        "type": "sqlitedb",
        "db": "/homeassistant/home-assistant_v2.db",
        "mode": "RWC"
    },
    {
        "id": "3e053bdac00312e5",
        "type": "global-config",
        "env": [],
        "modules": {
            "node-red-contrib-home-assistant-websocket": "0.80.3",
            "node-red-node-sqlite": "1.1.1"
        }
    }
]